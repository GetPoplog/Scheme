
/*  show_libraries.p                         Robin Popplestone.


/* (C) Copyright, University of Massachusetts, June 1994, All Rights Reserved
 *
 * This program carries no warranty.
 *
 * send bug reports and suggestions to pop@cs.umass.edu
 *

This program may reproduced for  academic and experimental purposes,  provided
the above attribution is preserved and extended as appropriate.

Commercial rights are reserved.
*/

         CONTENTS - (Use <ENTER> g to access required sections)

 --  Introduction - identifying files used in a POP-11 program.
 --  Health Warning - delayed loading and external loading, direct compilation.
 --  exclude_dirs(Dirs) prevents files from being recorded
 --  include_dirs(Dirs) allows files to be recorded
 --  script_move_library(L,Com,Path_old,Path_new,File) generates a script.
 --  show_libraries(doit)->V lists the files used to generate an application

Introduction - identifying files used in a POP-11 program.
----------------------------------------------------------
During the compilation of a POP-11 program, source files will be compiled from
a variety of directories. There will be library files from the POPLOG  system,
possibly files from libraries local to the site or to the particular user. And
some files will be  loaded directly, perhaps  with translation of  environment
variables. Thus it is not immediately  obvious what source files are  involved
in building the program.  "show_libraries.p" provides information about  which
source files have been compiled to make a give POP-11 program.



Health Warning - delayed loading and external loading, direct compilation.
---------------------------------------------------------------------------
If an application  relies on  autoloading source code  in response  to a  user
request, or on any other kind of dynamical loading, the files involved will
only be shown if the application has been put in a state

*/


vars L_auto = [], L_uses = [], L_load = [];
vars list_exclude = [];
section;

/*
exclude_dirs(Dirs) prevents files from being recorded
-----------------------------------------------------
Any file whose pathname begins with one of the paths in the list
Dirs is NOT recorded to be output by show_libraries or script_move_library.

*/

define lconstant exclude_dirs(Dirs);
  lvars Dirs;
  maplist(Dirs,sysfileok) -> Dirs;
  Dirs <> list_exclude -> list_exclude;
enddefine;

/*
include_dirs(Dirs) allows files to be recorded
----------------------------------------------

*/

define lconstant include_dirs(Dirs);
  lvars Dir,Dirs;
  for Dir in Dirs do
    delete(sysfileok(Dir),list_exclude) -> list_exclude;
  endfor;
enddefine;



lconstant uses_lib_idents_old = uses_lib_idents;

define uses_lib_idents(name,list,id_names,flags);
  libwarning(name);
  uses_lib_idents_old(name,list,id_names,flags);
enddefine;


endsection;

define lconstant excluded(Path,L_exclude)->is_excluded;
    lvars Path,L_exclude,is_excluded = false, Path_i;
    if Path then
        for Path_i in L_exclude do
            if issubstring(Path_i,Path) then
                true -> is_excluded;
                return
            endif;
        endfor;
    endif;
enddefine;

define lconstant occurs_in(W,L)->does;
  lvars entry, W,L,does = false;
  for entry in L do
    if W = front(entry) then return(true -> does)
    endif;
  endfor;
enddefine;

;;; trace syssearchpath;

define lconstant add_to_library_list(W,Id_SearchList,Id_List);
    lvars W,Id_SearchList,Id_List;
    lvars Path = syssearchpath(idval(Id_SearchList),W sys_><'.p');
    unless excluded(Path,list_exclude)
    or     occurs_in(W,idval(Id_List))
    then
        conspair(W,Path) ::idval(Id_List) -> idval(Id_List);
    endunless;
enddefine;

add_to_library_list(%ident popautolist,ident L_auto%) -> prautoloadwarn;
add_to_library_list(%ident popuseslist, ident L_uses%) -> libwarning;

define loadwarning(Path);
    lvars Path;
    unless Path(1) = `/` then
        current_directory sys_>< Path -> Path;
    endunless;
    unless excluded(Path,list_exclude)  then
        Path::L_load -> L_load;
    endunless;
enddefine;

define lconstant pr_entry(Pair);
  lvars Pair;
  printf('  "%p"', [%front(Pair)%]);
  tabto(20);
  printf('in  %p\n', [%back(Pair)%]);
enddefine;


/*
script_move_library(L,Com,Path_old,Path_new,File) generates a script.
---------------------------------------------------------------------------
This procedure  generates  a  Unix script  to  help  in tidying  up  a  POP-11
application. The script consists of a sequence of Unix commands of one or  two
arguments. Each command acts  on a file  used to build  the application .  For
example one such command, which might be generated by:

  script_move_library("lib","cp",'~joe/local', '$auto',charout);

is

  cp /home/tigger/joe/local/auto/ved_funny.p /home/tigger/poplog/local


L is a  specification of the  kind of library  or load file.  It can take  the
values "auto" "lib"  "uses" "load", or  a list containing  any of these.  Here
"auto" and "lib"

Com is a unix command, typically "cp".

Path_old is a path to a directory from which it is desired to move or copy
files used by the application. Any file used the application

Path_new can be <false>, in which case no second argument to the command
is generated. Otherwise it is -always- output (with environment variables
and user names translated) as the second argument of each command.

Thus typically Path_new and Path_old will be directories.

File is a file name or character sink, to

*/

define script_move_library(L,Com,Path_old, Path_new, FileSpec);
    lvars L,Com,Path_old,Path_new,File,FileSpec;
    if isstring(FileSpec) then discout(FileSpec)
    else FileSpec
    endif -> File;
    dlocal cucharout = File;
    sysfileok(Path_old) -> Path_old;
    unless Path_old then
        mishap('Old path name not valid', [%Path_old%]);
    endunless;
    if Path_new then
        sysfileok(Path_new) -> Path_new;
        unless Path_new then
            mishap('New path name not valid', [%Path_new%]);
        endunless;
    endif;
    lvars l,
        Paths_old = [%Path_old%];
        if L = "uses" then L_uses
        elseif L = "lib" then L_uses
        elseif L = "auto" then L_auto
        elseif L = "load" then L_load
        elseif islist(L) then
            applist(L,script_move_library(%Com,Path_old,Path_new,File%));
            return;
        else mishap('Specify "auto", "uses" or "load" for script',[^L]);
        endif -> L;
        for l in L do
            lvars Lib = if ispair(l) then back(l) else l endif;
            if(excluded(Lib,Paths_old)) then
                printf('%p %p\n', [%Com,Lib%]);
                if Path_new then
                    printf(' %p\n',[%Path_new%])
                else
                    printf('\n');
                endif;
            endif
        endfor;
        if isstring(FileSpec) then File(termin);
        endif;
    enddefine;

/*
show_libraries(doit)->V lists the files used to generate an application
--------------------------------------------------------------------------
This procedure provides the -only- interface to the whole facility. If  -doit-
is <true> then  all the  files loaded either  directly, or  as library  files,
between the last time that -show_libraries.p- was compiled and the call of
show_libraries are printed out.

V is a vector of utility procedures.
    show_libraries(false)==>

    ** {<procedure script_move_library>
        <procedure exclude_dirs> <procedure include_dirs>}

The uses of these procedures are documented elsewhere in this file.

*/

define show_libraries(doit) -> vector_of_procs;
    lvars doit, vector_of_procs;
    if doit then
        printf('\n\nExcluded directories:\n');
        applist(list_exclude,sp(%2%)<>npr);
        dlocal %class_print(pair_key)% = sys_syspr;
        printf( '\n\nAutoloaded files:\n');
        applist(L_auto,pr_entry);
        pr('\n\nLibrary files:\n');
        applist(L_uses,pr_entry);
        pr('\n\n Loaded files:\n');
        applist(L_load,sp(%2%)<>npr);
        pr('\nEnd of library listing\n');
    endif;
    /*
    if identprops("source_of_proc")/==undef then
        npr('\nMultiply defined procedures:\n');
        appproperty(source_of_proc,
            procedure(P,File);
                if islist(File) then
                    pr(P);  lvars F;
                       for F in File do tabto(20); npr(F);
                       endfor;
                endif;
            endprocedure
        );
    endif;
    */
    {%script_move_library,exclude_dirs,include_dirs%} -> vector_of_procs;
enddefine;



uses show_libraries;       ;;; Enter yourself in the list.
